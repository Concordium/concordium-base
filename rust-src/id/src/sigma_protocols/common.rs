use crypto_common::*;
use random_oracle::*;

#[cfg(test)]
pub fn generate_challenge_prefix<R: rand::Rng>(csprng: &mut R) -> Vec<u8> {
    // length of the challenge
    let l = csprng.gen_range(0, 1000);
    let mut challenge_prefix = vec![0; l];
    for v in challenge_prefix.iter_mut() {
        *v = csprng.gen();
    }
    challenge_prefix
}

/// The common data known to the prover and verifier, i.e., public values and
/// coefficients.
pub trait SigmaProtocolCommon {
    /// Prover's commit message.
    type CommitMessage: Serial;
    /// Prover's witness.
    type ProverWitness: Serialize;
    /// Inherent challenge type. This needs to be convertible from the Challenge
    /// type above.
    type ProtocolChallenge;

    /// Given a random oracle, feed it all of the public input of this instance,
    /// and return the new state.
    fn public(&self, ro: RandomOracle) -> RandomOracle;

    fn get_challenge(&self, challenge: &Challenge) -> Self::ProtocolChallenge;
}

/// An abstraction of a prover in sigma protocols.
pub trait SigmaProtocolProver: SigmaProtocolCommon {
    /// Prover's state after the first message.
    type ProverState;
    /// The prover's secret data. The intention is that this is a reference
    /// type, and hence the Copy requirement.
    type SecretData: Clone + Copy;

    /// First message generated by the prover. We allow this function
    /// to return 'None' if the inputs are inconsistent.
    /// The arguments are
    /// - self -- the prover's public and secret data
    /// - secret -- secret data known to the prover only
    /// - csprng -- a cryptographically secure random number generator
    fn commit_point<R: rand::Rng>(
        &self,
        secret: Self::SecretData,
        csprng: &mut R,
    ) -> Option<(Self::CommitMessage, Self::ProverState)>;

    /// Third message generated by the prover. We allow this function to return
    /// 'None' if the inputs are inconsistent.
    /// - self -- the prover's public and secret data
    /// - secret -- secret data known to the prover only
    /// - state -- the state returned from the 'commit_point' call
    /// - challenge -- computed challenge
    /// This function is pure and deterministic.
    fn generate_witness(
        &self,
        secret: Self::SecretData,
        state: Self::ProverState,
        challenge: &Self::ProtocolChallenge,
    ) -> Option<Self::ProverWitness>;
}

pub trait SigmaProtocolVerifier: SigmaProtocolCommon {
    /// Combine the public outputs from the third message with the challenge
    /// and produce a commitment for verification.
    /// - challenge -- computed challenge
    /// - self -- the verifier's public data
    /// This function is pure and deterministic.
    /// It is allowed to return 'None' if some of the input data is malformed,
    /// e.g., vectors of inconsistent lengths.
    fn extract_point(
        &self,
        challenge: &Self::ProtocolChallenge,
        witness: &Self::ProverWitness,
    ) -> Option<Self::CommitMessage>;
}

#[derive(Debug, Serialize)]
/// Generic structure to contain a single sigma proof.
pub struct SigmaProof<W: Serialize> {
    pub challenge: Challenge,
    pub witness:   W,
}

#[derive(Serialize)]
pub struct AndWitness<W1: Serialize, W2: Serialize> {
    pub w1: W1,
    pub w2: W2,
}

/// An adapter to combine multiple provers or multiple verifiers.
/// The marker type C is for convenience in use with the
/// SigmaProtocolProver/Verifier traits below.
pub struct AndAdapter<P1, P2> {
    first:  P1,
    second: P2,
}

impl<P1: SigmaProtocolCommon, P2: SigmaProtocolCommon> SigmaProtocolCommon for AndAdapter<P1, P2> {
    type CommitMessage = (P1::CommitMessage, P2::CommitMessage);
    // FIXME: The challenge pair is inefficient, since we will typically
    // have a pair of the same element, however in the grand scheme of things
    // this is a minor inefficiency.
    type ProtocolChallenge = (P1::ProtocolChallenge, P2::ProtocolChallenge);
    type ProverWitness = AndWitness<P1::ProverWitness, P2::ProverWitness>;

    fn public(&self, ro: RandomOracle) -> RandomOracle {
        let ro1 = self.first.public(ro);
        self.second.public(ro1)
    }

    fn get_challenge(&self, challenge: &Challenge) -> Self::ProtocolChallenge {
        (
            self.first.get_challenge(challenge),
            self.second.get_challenge(challenge),
        )
    }
}

impl<P1: SigmaProtocolProver, P2: SigmaProtocolProver> SigmaProtocolProver for AndAdapter<P1, P2> {
    type ProverState = (P1::ProverState, P2::ProverState);
    type SecretData = (P1::SecretData, P2::SecretData);

    fn commit_point<R: rand::Rng>(
        &self,
        secret: Self::SecretData,
        csprng: &mut R,
    ) -> Option<(Self::CommitMessage, Self::ProverState)> {
        let (m1, s1) = self.first.commit_point(secret.0, csprng)?;
        let (m2, s2) = self.second.commit_point(secret.1, csprng)?;
        Some(((m1, m2), (s1, s2)))
    }

    fn generate_witness(
        &self,
        secret: Self::SecretData,
        state: Self::ProverState,
        challenge: &Self::ProtocolChallenge,
    ) -> Option<Self::ProverWitness> {
        let w1 = self
            .first
            .generate_witness(secret.0, state.0, &challenge.0)?;
        let w2 = self
            .second
            .generate_witness(secret.1, state.1, &challenge.1)?;
        Some(AndWitness { w1, w2 })
    }
}

impl<P1: SigmaProtocolVerifier, P2: SigmaProtocolVerifier> SigmaProtocolVerifier
    for AndAdapter<P1, P2>
{
    fn extract_point(
        &self,
        challenge: &Self::ProtocolChallenge,
        witness: &Self::ProverWitness,
    ) -> Option<Self::CommitMessage> {
        let p1 = self.first.extract_point(&challenge.0, &witness.w1)?;
        let p2 = self.second.extract_point(&challenge.1, &witness.w2)?;
        Some((p1, p2))
    }
}

impl<P1: SigmaProtocolProver, P2: SigmaProtocolProver> AndAdapter<P1, P2> {
    /// Extend the current adapter with a new prover.
    pub fn add_prover<P3: SigmaProtocolProver>(
        self,
        additional_prover: P3,
    ) -> AndAdapter<AndAdapter<P1, P2>, P3> {
        AndAdapter {
            first:  self,
            second: additional_prover,
        }
    }
}

impl<P1: SigmaProtocolVerifier, P2: SigmaProtocolVerifier> AndAdapter<P1, P2> {
    /// Extend the current adapter with a new verifier.
    pub fn add_verifier<P3: SigmaProtocolVerifier>(
        self,
        additional_verifier: P3,
    ) -> AndAdapter<AndAdapter<P1, P2>, P3> {
        AndAdapter {
            first:  self,
            second: additional_verifier,
        }
    }
}

/// Given a sigma protocol prover and a context (in the form of the random
/// oracle), produce a sigma proof. This function can return 'None' if the input
/// data is inconsistent.
pub fn prove<R: rand::Rng, D: SigmaProtocolProver>(
    ro: RandomOracle,
    prover: &D,
    secret: D::SecretData,
    csprng: &mut R,
) -> Option<SigmaProof<D::ProverWitness>> {
    let (point, state) = prover.commit_point(secret, csprng)?;
    let challenge_bytes = prover.public(ro).append(&point).get_challenge();
    let challenge = prover.get_challenge(&challenge_bytes);
    let witness = prover.generate_witness(secret, state, &challenge)?;
    Some(SigmaProof {
        challenge: challenge_bytes,
        witness,
    })
}

/// Verify a single sigma proof, given a sigma proof verifier and a context in
/// the form of an instantiated random oracle.
pub fn verify<D: SigmaProtocolVerifier>(
    ro: RandomOracle,
    verifier: &D,
    proof: &SigmaProof<D::ProverWitness>,
) -> bool {
    let challenge = verifier.get_challenge(&proof.challenge);
    match verifier.extract_point(&challenge, &proof.witness) {
        None => false,
        Some(ref point) => {
            let computed_challenge = verifier.public(ro).append(&point).get_challenge();
            computed_challenge == proof.challenge
        }
    }
}
