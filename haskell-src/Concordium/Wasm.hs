{-# LANGUAGE DerivingVia, DeriveGeneric, DeriveFunctor, ScopedTypeVariables #-}
module Concordium.Wasm where

import GHC.Generics
import Data.Word
import Data.ByteString(ByteString)
import qualified Data.ByteString as BS
import Data.ByteString.Short(ShortByteString)
import qualified Data.ByteString.Short as BSS
import Data.Serialize
import qualified Data.Aeson as AE
import Data.Text(Text)
import qualified Data.Text.Encoding as Text
import qualified Data.Set as Set
import Data.Hashable

import Concordium.Crypto.ByteStringHelpers(ByteStringHex(..))
import qualified Concordium.Crypto.SHA256 as H

import Concordium.Types
import Concordium.Types.HashableTo

type ModuleSource = ByteString

-- |Web assembly module in binary format.
data WasmModule = WasmModule {
  -- |Version of the Wasm standard and on-chain API this module corresponds to.
  wasmVersion :: Word32,
  -- |Source in binary wasm format.
  wasmSource :: ModuleSource
  } deriving(Eq, Show)

getModuleRef :: WasmModule -> ModuleRef
getModuleRef wm = ModuleRef (getHash wm)

-- |Name of an init method inside a module.
-- TODO: Naming scheme enforcement.
newtype InitName = InitName { initName :: Text }
    deriving(Eq, Show, Ord)
    deriving(AE.ToJSON, AE.FromJSON) via Text

-- |Name of a receive method inside a module.
-- TODO: Naming scheme enforcement.
newtype ReceiveName = ReceiveName { receiveName :: Text }
    deriving (Eq, Show, Ord)
    deriving(AE.ToJSON, AE.FromJSON) via Text

-- |Parameter to either an init method or to a receive method.
newtype Parameter = Parameter { parameter :: ShortByteString }
    deriving(Eq, Show)
    deriving(AE.ToJSON, AE.FromJSON) via ByteStringHex

-- |Web assembly module in binary format, instrumented with whatever it needs to
-- be instrumented with. To be determined.
data InstrumentedModule = InstrumentedWasmModule {
  -- |Version of the Wasm standard and on-chain API this module corresponds to.
  imWasmVersion :: Word32,
  -- |Source in binary wasm format.
  imWasmSource :: ModuleSource
  } deriving(Eq, Show, Generic)


-- |A Wasm module interface with exposed entry-points.
data ModuleInterface = ModuleInterface {
  -- |Reference of the module on the chain.
  miModuleRef :: !ModuleRef,
  -- |Init methods exposed by this module.
  -- They should each be exposed with a type Amount -> ()
  miExposedInit :: !(Set.Set InitName),
  -- |Receive methods exposed by this module.
  -- They should each be exposed with a type Amount -> ()
  miExposedReceive :: !(Set.Set ReceiveName),
  -- |Module source in binary format, instrumented with whatever it needs to be instrumented with.
  miModule :: !InstrumentedModule,
  -- |Size of the module in bytes this interface is derived from.
  miSize :: !Word64
  } deriving(Eq, Show, Generic)

-- |Additional data needed specifically by the init method of the contract.
data InitContext = InitContext
    {initOrigin :: !AccountAddress}

-- |Additional data needed specifically by the receive method of the contract.
data ReceiveContext = ReceiveContext
  { -- | The address of the account which initiated the top-level transaction.
    invoker :: !AccountAddress
    -- | The address of the contract being invoked.
  , selfAddress :: !ContractAddress
    -- | Amount on the smart contract instnace just before the receive method is
    -- called.
  , selfBalance :: !Amount
  -- |Address of the account or contract who sent a message to the contract.
  , sender :: !Address
  }

-- |Energy used by the Wasm interpreter.
newtype InterpreterEnergy = InterpreterEnergy { iEnergy :: Word64 }
    deriving(Eq, Ord, Show, Num, Enum, Integral, Real)

-- * Interpreter related functions.

-- |Output events generated by a single invocation of a receive method.
data OutputEvent = 
  -- |Transfer this many tokens to an account.
  TSimpleTransfer {
      erTo :: !AccountAddress,
      erAmount :: !Amount
      }
  | TSend {
      erAddr :: !ContractAddress,
      erName :: !ReceiveName,
      erAmount :: !Amount,
      erParameter :: !Parameter
      }
  deriving(Eq, Show)

data EventsTree a =
  -- |Singleton event.
  Base !a
  -- |Both left and right subtrees must succeed.
  | And !(EventsTree a) !(EventsTree a)
  -- |Try to execute events in the left subtree, if that
  -- fails try the right.
  | Or !(EventsTree a) !(EventsTree a)
  deriving(Eq, Show, Functor)

-- |Successful result of execution of a single contract invocation.
-- |TODO: To be extended in the future.
data ReceiveExecutionResult =
  -- |Simple accept with no other events.
  Accept
  -- |A tree of events.
  | EventsTree (EventsTree OutputEvent)

-- |Event as reported by contract execution.
newtype ContractEvent = ContractEvent BSS.ShortByteString
    deriving(Eq, Show, Serialize)
    deriving(AE.ToJSON, AE.FromJSON) via ByteStringHex

data SuccessfulResultData a = SuccessfulResultData {
  messages :: !a,
  logs :: [ContractEvent],
  newState :: !ContractState
  }

-- |Reason for failure of contract execution.
data ContractExecutionFailure =
  ContractReject -- ^Contract decided to terminate execution.
  | RuntimeFailure -- ^A trap was triggered.
  deriving(Eq, Show)

-- |Apply an init function which is assumed to be part of the given module.
applyInitFun
    :: ModuleInterface
    -> ChainMetadata -- ^Metadata available to the contract.
    -> InitContext
    -> InitName  -- ^Which method to invoke.
    -> Parameter -- ^Parameters available to the method.
    -> Amount  -- ^Amount the contract is initialized with.
    -> InterpreterEnergy  -- ^Amount of energy available for execution.
    -> Maybe (Either ContractExecutionFailure (SuccessfulResultData ()), InterpreterEnergy)
    -- ^Nothing if execution used up all the energy,
    -- and otherwise the result of execution with remaining interpreter energy.
applyInitFun = error "Unimplemented."

-- |Apply a receive function which is assumed to be part of the given module.
applyReceiveFun
    :: ModuleInterface
    -> ChainMetadata -- ^Metadata available to the contract.
    -> ReceiveContext
    -> ReceiveName  -- ^Which method to invoke.
    -> Parameter -- ^Parameters available to the method.
    -> Amount  -- ^Amount the contract is initialized with.
    -> ContractState -- ^State of the contract to start in.
    -> InterpreterEnergy  -- ^Amount of energy available for execution.
    -> Maybe (Either ContractExecutionFailure (SuccessfulResultData ReceiveExecutionResult), InterpreterEnergy)
    -- ^Nothing if execution used up all the energy,
    -- and otherwise the result of execution with remaining interpreter energy.
applyReceiveFun = error "Unimplemented."

-- |Process a module as received and make a module interface.
-- This should check the module is well-formed, and has the right imports and exports.
processModule :: WasmModule -> Maybe ModuleInterface
processModule = error "Unimplemented."

-- |State of a smart contract. In general we don't know anything other than
-- it is a sequence of bytes.
-- FIXME: In the future this should be more structured allowing for more sharing.
newtype ContractState = ContractState {contractState :: BS.ByteString }
    deriving(Eq, Show)


-- |Type used to measure contract storage costs.
newtype ByteSize = ByteSize { _byteSize :: Word64 }
    deriving (Show, Read, Eq, Enum, Ord, Num, Real, Integral, Hashable, Bounded) via Word64

-- |It is assumed the type `a` can reliable represent 64-bit unsigned values.
contractStateSize :: forall a . Integral a => ContractState -> a -> Maybe a
contractStateSize cs bs =
  if len <= bs then Just len
  else Nothing
  where len = fromIntegral (BS.length (contractState cs))

-- The serialize instance uses Word32 for length. This should be reasonable since
-- no instance should ever be able to produce a state bigger than 4GB.
instance Serialize ContractState where
  put ContractState{..} = do
    putWord32be (fromIntegral (BS.length contractState))
    putByteString contractState

  get = do
    len <- fromIntegral <$> getWord32be
    ContractState <$> getByteString len

instance HashableTo H.Hash ContractState where
  getHash cs = H.hash (encode cs)

-- * Implementation of instances and the like.

instance Serialize InstrumentedModule where
-- FIXME: A more principled serialize method.

instance Serialize ModuleInterface where
-- FIXME: A more principled serialize method, order and ensure the order of sets.

instance Serialize WasmModule where
  put WasmModule{..} =
    putWord32be wasmVersion <>
    putByteStringWord32 wasmSource

  get = do
    wasmVersion <- getWord32be
    wasmSource <- getByteStringWord32
    return WasmModule{..}

instance HashableTo H.Hash WasmModule where
  -- Hash the serialization directly, perhaps this needs to be revisited in the future.
  getHash wm = H.hash (encode wm)

instance Serialize InitName where
  put = putByteStringWord32 . Text.encodeUtf8 . initName
  get = do
    bs <- getByteStringWord32
    case Text.decodeUtf8' bs of
      Left _ -> fail "Not a valid utf-8 encoding."
      Right t -> return (InitName t)

instance Serialize ReceiveName where
  put = putByteStringWord32 . Text.encodeUtf8 . receiveName
  get = do
    bs <- getByteStringWord32
    case Text.decodeUtf8' bs of
      Left _ -> fail "Not a valid utf-8 encoding."
      Right t -> return (ReceiveName t)

instance Serialize Parameter where
  put = putShortByteStringWord32 . parameter
  get = Parameter <$> getShortByteStringWord32

-- |Get a bytestring with length serialized as big-endian 4 bytes.
getByteStringWord32 :: Get ByteString
getByteStringWord32 = do
  len <- fromIntegral <$> getWord32be
  getByteString len

-- |Put a bytestring with length serialized as big-endian 4 bytes.
-- This function assumes the string length fits into 4 bytes.
putByteStringWord32 :: Putter ByteString
putByteStringWord32 bs =
  let len = fromIntegral (BS.length bs)
  in putWord32be len <> putByteString bs


-- |Get a bytestring with length serialized as big-endian 4 bytes.
getShortByteStringWord32 :: Get ShortByteString
getShortByteStringWord32 = do
  len <- fromIntegral <$> getWord32be
  getShortByteString len

-- |Put a bytestring with length serialized as big-endian 4 bytes.
-- This function assumes the string length fits into 4 bytes.
putShortByteStringWord32 :: Putter ShortByteString
putShortByteStringWord32 bs =
  let len = fromIntegral (BSS.length bs)
  in putWord32be len <> putShortByteString bs
