{-# LANGUAGE DerivingVia, DeriveGeneric, DeriveFunctor, ScopedTypeVariables #-}
module Concordium.Wasm where

import GHC.Generics
import Data.Word
import Control.Monad
import Data.ByteString(ByteString)
import qualified Data.ByteString as BS
import Data.ByteString.Short(ShortByteString)
import qualified Data.ByteString.Short as BSS
import Data.Serialize
import qualified Data.Aeson as AE
import Data.Text(Text)
import qualified Data.Text.Encoding as Text
import qualified Data.Set as Set
import Data.Hashable

import Concordium.Crypto.ByteStringHelpers(ByteStringHex(..))
import qualified Concordium.Crypto.SHA256 as H

import Concordium.Types
import Concordium.Types.HashableTo

type ModuleSource = ByteString

-- |Web assembly module in binary format.
data WasmModule = WasmModule {
  -- |Version of the Wasm standard and on-chain API this module corresponds to.
  wasmVersion :: Word32,
  -- |Source in binary wasm format.
  wasmSource :: ModuleSource
  } deriving(Eq, Show)

getModuleRef :: WasmModule -> ModuleRef
getModuleRef wm = ModuleRef (getHash wm)

-- |Name of an init method inside a module.
-- TODO: Naming scheme enforcement.
newtype InitName = InitName { initName :: Text }
    deriving(Eq, Show, Ord)
    deriving(AE.ToJSON, AE.FromJSON) via Text

-- |Name of a receive method inside a module.
-- TODO: Naming scheme enforcement.
newtype ReceiveName = ReceiveName { receiveName :: Text }
    deriving (Eq, Show, Ord)
    deriving(AE.ToJSON, AE.FromJSON) via Text

-- |Parameter to either an init method or to a receive method.
newtype Parameter = Parameter { parameter :: ShortByteString }
    deriving(Eq, Show)
    deriving(AE.ToJSON, AE.FromJSON) via ByteStringHex

-- |Web assembly module in binary format, instrumented with whatever it needs to
-- be instrumented with. To be determined.
data InstrumentedModule = InstrumentedWasmModule {
  -- |Version of the Wasm standard and on-chain API this module corresponds to.
  imWasmVersion :: Word32,
  -- |Source in binary wasm format.
  imWasmSource :: ModuleSource
  } deriving(Eq, Show, Generic)


-- |A Wasm module interface with exposed entry-points.
data ModuleInterface = ModuleInterface {
  -- |Reference of the module on the chain.
  miModuleRef :: !ModuleRef,
  -- |Init methods exposed by this module.
  -- They should each be exposed with a type Amount -> ()
  miExposedInit :: !(Set.Set InitName),
  -- |Receive methods exposed by this module.
  -- They should each be exposed with a type Amount -> ()
  miExposedReceive :: !(Set.Set ReceiveName),
  -- |Module source in binary format, instrumented with whatever it needs to be instrumented with.
  miModule :: !InstrumentedModule,
  -- |Size of the module in bytes this interface is derived from.
  miSize :: !Word64
  } deriving(Eq, Show, Generic)

-- |Additional data needed specifically by the init method of the contract.
data InitContext = InitContext
    {initOrigin :: !AccountAddress}

-- |Additional data needed specifically by the receive method of the contract.
data ReceiveContext = ReceiveContext
  { -- | The address of the account which initiated the top-level transaction.
    invoker :: !AccountAddress
    -- | The address of the contract being invoked.
  , selfAddress :: !ContractAddress
    -- | Amount on the smart contract instnace just before the receive method is
    -- called.
  , selfBalance :: !Amount
  -- |Address of the account or contract who sent a message to the contract.
  , sender :: !Address
  }

-- |Energy used by the Wasm interpreter.
newtype InterpreterEnergy = InterpreterEnergy { iEnergy :: Word64 }
    deriving(Eq, Ord, Show, Num, Enum, Integral, Real)

-- * Interpreter related functions.

-- |Output events generated by a single invocation of a receive method.
data OutputEvent = 
  -- |Transfer this many tokens to an account.
  TSimpleTransfer {
      erTo :: !AccountAddress,
      erAmount :: !Amount
      }
  | TSend {
      erAddr :: !ContractAddress,
      erName :: !ReceiveName,
      erAmount :: !Amount,
      erParameter :: !Parameter
      }
  deriving(Eq, Show)

instance Serialize OutputEvent where
  put TSimpleTransfer{..} = putWord8 1 <> put erTo <> put erAmount
  put TSend{..} = putWord8 0 <> put erAddr <> put erName <> put erAmount <> put erParameter

  get = getWord8 >>= \case
    0 -> do
      erTo <- get
      erAmount <- get
      return TSimpleTransfer{..}
    1 -> do
      erAddr <- get
      erName <- get
      erAmount <- get
      erParameter <- get
      return TSend{..}
    tag -> fail $ "Unsupported tag: " ++ show tag

data EventsTree a =
  -- |Singleton event.
  Base !a
  -- |Both left and right subtrees must succeed.
  | And !(EventsTree a) !(EventsTree a)
  -- |Try to execute events in the left subtree, if that
  -- fails try the right.
  | Or !(EventsTree a) !(EventsTree a)
  deriving(Eq, Show, Functor)

eventsTreeSize :: EventsTree a -> Int
eventsTreeSize = go
  where go (Base _) = 1
        go (And l r) = go l + go r
        go (Or l r) = go l + go r

-- |Successful result of execution of a single contract invocation.
-- |TODO: To be extended in the future.
data ReceiveExecutionResult =
  -- |Simple accept with no other events.
  Accept
  -- |A tree of events.
  | EventsTree (EventsTree OutputEvent)

getEventsTree :: Word32 -> Get (EventsTree OutputEvent)
getEventsTree = go []
    where go acc n | n == 0 = if null acc then fail "Empty list of events." else return (foldr1 And acc)
                   | otherwise = do
                       lookAhead getWord8 >>= \case
                         2 -> case acc of
                           r:l:rest -> getWord8 >> go (And l r : rest) (n-1)
                           _ -> fail "Malformed and stack."
                         3 -> case acc of
                           r:l:rest -> getWord8 >> go (Or l r : rest) (n-1)
                           _ -> fail "Malformed or stack."
                         _ -> do
                           b <- get
                           go (Base b : acc) (n-1)

instance Serialize ReceiveExecutionResult where
  put Accept = putWord32be 0
  put (EventsTree evs) =
    putWord32be (fromIntegral (eventsTreeSize evs)) <> error "EventsTree.Serialize: Unimplemented."

  get = getWord32be >>= \case
    0 -> return Accept
    n -> EventsTree <$> getEventsTree n

-- |Event as reported by contract execution.
newtype ContractEvent = ContractEvent BSS.ShortByteString
    deriving(Eq, Show)
    deriving(AE.ToJSON, AE.FromJSON) via ByteStringHex

instance Serialize ContractEvent where
  put (ContractEvent ev) = putShortByteStringWord32 ev
  get = ContractEvent <$> getShortByteStringWord32

data SuccessfulResultData a = SuccessfulResultData {
  messages :: !a,
  newState :: !ContractState,
  logs :: ![ContractEvent]
  }

-- |Reason for failure of contract execution.
data ContractExecutionFailure =
  ContractReject ![ContractEvent]-- ^Contract decided to terminate execution.
  | RuntimeFailure -- ^A trap was triggered.
  deriving(Eq, Show)

-- |State of a smart contract. In general we don't know anything other than
-- it is a sequence of bytes.
-- FIXME: In the future this should be more structured allowing for more sharing.
newtype ContractState = ContractState {contractState :: BS.ByteString }
    deriving(Eq)

-- The show instance just displays the bytes directly.
instance Show ContractState where
  show ContractState{..} = show (BS.unpack contractState)


-- |Type used to measure contract storage costs.
newtype ByteSize = ByteSize { _byteSize :: Word64 }
    deriving (Show, Read, Eq, Enum, Ord, Num, Real, Integral, Hashable, Bounded) via Word64

-- |It is assumed the type `a` can reliable represent 64-bit unsigned values.
contractStateSize :: forall a . Integral a => ContractState -> a -> Maybe a
contractStateSize cs bs =
  if len <= bs then Just len
  else Nothing
  where len = fromIntegral (BS.length (contractState cs))

-- The serialize instance uses Word32 for length. This should be reasonable since
-- no instance should ever be able to produce a state bigger than 4GB.
instance Serialize ContractState where
  put ContractState{..} = do
    putWord32be (fromIntegral (BS.length contractState))
    putByteString contractState

  get = do
    len <- fromIntegral <$> getWord32be
    ContractState <$> getByteString len

instance HashableTo H.Hash ContractState where
  getHash cs = H.hash (encode cs)

-- * Implementation of instances and the like.

instance Serialize InstrumentedModule where
-- FIXME: A more principled serialize method.

instance Serialize ModuleInterface where
-- FIXME: A more principled serialize method, order and ensure the order of sets.

instance Serialize WasmModule where
  put WasmModule{..} =
    putWord32be wasmVersion <>
    putByteStringWord32 wasmSource

  get = do
    wasmVersion <- getWord32be
    wasmSource <- getByteStringWord32
    return WasmModule{..}

instance HashableTo H.Hash WasmModule where
  -- Hash the serialization directly, perhaps this needs to be revisited in the future.
  getHash wm = H.hash (encode wm)

instance Serialize InitName where
  put = putByteStringWord32 . Text.encodeUtf8 . initName
  get = do
    bs <- getByteStringWord32
    case Text.decodeUtf8' bs of
      Left _ -> fail "Not a valid utf-8 encoding."
      Right t -> return (InitName t)

instance Serialize ReceiveName where
  put = putByteStringWord32 . Text.encodeUtf8 . receiveName
  get = do
    bs <- getByteStringWord32
    case Text.decodeUtf8' bs of
      Left _ -> fail "Not a valid utf-8 encoding."
      Right t -> return (ReceiveName t)

instance Serialize Parameter where
  put = putShortByteStringWord32 . parameter
  get = Parameter <$> getShortByteStringWord32

instance Serialize InitContext where
  put (InitContext origin) = put origin
  get = InitContext <$> get

instance Serialize ReceiveContext where
  put ReceiveContext{..} =
      put invoker <>
      put selfAddress <>
      put selfBalance <>
      put sender
  get = do
    invoker <- get
    selfAddress <- get
    selfBalance <- get
    sender <- get
    return ReceiveContext{..}

instance Serialize a => Serialize (SuccessfulResultData a) where
  put SuccessfulResultData{..} =
    put newState <>
    putWord32be (fromIntegral (length logs)) <>
    mapM_ put logs <>
    put messages

  get = do
    newState <- get
    len <- fromIntegral <$> getWord32be
    logs <- replicateM len get
    messages <- get
    return SuccessfulResultData{..}

-- |Get a bytestring with length serialized as big-endian 4 bytes.
getByteStringWord32 :: Get ByteString
getByteStringWord32 = do
  len <- fromIntegral <$> getWord32be
  getByteString len

-- |Put a bytestring with length serialized as big-endian 4 bytes.
-- This function assumes the string length fits into 4 bytes.
putByteStringWord32 :: Putter ByteString
putByteStringWord32 bs =
  let len = fromIntegral (BS.length bs)
  in putWord32be len <> putByteString bs


-- |Get a bytestring with length serialized as big-endian 4 bytes.
getShortByteStringWord32 :: Get ShortByteString
getShortByteStringWord32 = do
  len <- fromIntegral <$> getWord32be
  getShortByteString len

-- |Put a bytestring with length serialized as big-endian 4 bytes.
-- This function assumes the string length fits into 4 bytes.
putShortByteStringWord32 :: Putter ShortByteString
putShortByteStringWord32 bs =
  let len = fromIntegral (BSS.length bs)
  in putWord32be len <> putShortByteString bs

